/**
 * Player vidéo avancé avec support HLS et Direct Streaming
 * Combine les fonctionnalités de SecureVideoPlayer avec le streaming adaptatif
 */

"use client";

import type { VideoQuality } from "@/services/videoStreamingService";
import Hls from "hls.js";
import { useEffect, useRef, useState } from "react";
import {
  FiMaximize,
  FiPause,
  FiPlay,
  FiSettings,
  FiVolume2,
  FiVolumeX,
} from "react-icons/fi";

interface AdvancedVideoPlayerProps {
  streamUrl: string;
  method: "hls" | "direct";
  title?: string;
  poster?: string;
  autoplay?: boolean;
  availableQualities?: VideoQuality[];
  currentQuality?: VideoQuality;
  onQualityChange?: (quality: VideoQuality) => void;
  className?: string;
}

export function AdvancedVideoPlayer({
  streamUrl,
  method,
  title,
  poster,
  autoplay = false,
  availableQualities = ["auto", "1080p", "720p", "480p", "360p"],
  currentQuality = "auto",
  onQualityChange,
  className = "",
}: AdvancedVideoPlayerProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const hlsRef = useRef<Hls | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const [isPlaying, setIsPlaying] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [volume, setVolume] = useState(1);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [buffered, setBuffered] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showControls, setShowControls] = useState(true);
  const [showSettings, setShowSettings] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Initialisation du player
  useEffect(() => {
    if (!videoRef.current || !streamUrl) return;

    const video = videoRef.current;

    // Cleanup HLS existant
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }

    const isHLSUrl = streamUrl.includes(".m3u8") || method === "hls";

    if (isHLSUrl) {
      // HLS natif (Safari)
      if (video.canPlayType("application/vnd.apple.mpegurl")) {
        video.src = streamUrl;
        if (autoplay) {
          video.play().catch((err) => {
            console.error("Erreur autoplay:", err);
          });
        }
      }
      // HLS.js
      else if (Hls.isSupported()) {
        const hls = new Hls({
          enableWorker: true,
          lowLatencyMode: false,
          backBufferLength: 90,
        });

        hlsRef.current = hls;
        hls.loadSource(streamUrl);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          if (autoplay) {
            video.play().catch((err) => {
              console.error("Erreur autoplay:", err);
            });
          }
        });

        hls.on(Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                hls.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                hls.recoverMediaError();
                break;
              default:
                setError("Erreur de chargement du stream");
                hls.destroy();
                break;
            }
          }
        });
      } else {
        setError("HLS non supporté");
      }
    } else {
      // Direct streaming
      video.src = streamUrl;
      if (autoplay) {
        video.play().catch((err) => {
          console.error("Erreur autoplay:", err);
        });
      }
    }

    return () => {
      if (hlsRef.current) {
        hlsRef.current.destroy();
      }
    };
  }, [streamUrl, method, autoplay]);

  // Event listeners
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => setCurrentTime(video.currentTime);
    const handleDurationChange = () => setDuration(video.duration);
    const handleProgress = () => {
      if (video.buffered.length > 0) {
        setBuffered(video.buffered.end(video.buffered.length - 1));
      }
    };
    const handlePlay = () => setIsPlaying(true);
    const handlePause = () => setIsPlaying(false);
    const handleVolumeChange = () => {
      setVolume(video.volume);
      setIsMuted(video.muted);
    };

    video.addEventListener("timeupdate", handleTimeUpdate);
    video.addEventListener("durationchange", handleDurationChange);
    video.addEventListener("progress", handleProgress);
    video.addEventListener("play", handlePlay);
    video.addEventListener("pause", handlePause);
    video.addEventListener("volumechange", handleVolumeChange);

    return () => {
      video.removeEventListener("timeupdate", handleTimeUpdate);
      video.removeEventListener("durationchange", handleDurationChange);
      video.removeEventListener("progress", handleProgress);
      video.removeEventListener("play", handlePlay);
      video.removeEventListener("pause", handlePause);
      video.removeEventListener("volumechange", handleVolumeChange);
    };
  }, []);

  // Fullscreen listener
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);

  // Contrôles
  const togglePlay = () => {
    if (!videoRef.current) return;
    if (isPlaying) {
      videoRef.current.pause();
    } else {
      videoRef.current.play();
    }
  };

  const toggleMute = () => {
    if (!videoRef.current) return;
    videoRef.current.muted = !isMuted;
  };

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!videoRef.current) return;
    const newVolume = parseFloat(e.target.value);
    videoRef.current.volume = newVolume;
  };

  const handleSeek = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!videoRef.current) return;
    const newTime = parseFloat(e.target.value);
    videoRef.current.currentTime = newTime;
  };

  const toggleFullscreen = () => {
    if (!containerRef.current) return;

    if (!isFullscreen) {
      containerRef.current.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  const formatTime = (seconds: number): string => {
    if (!isFinite(seconds)) return "0:00";
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };

  const progressPercentage = duration > 0 ? (currentTime / duration) * 100 : 0;
  const bufferedPercentage = duration > 0 ? (buffered / duration) * 100 : 0;

  if (error) {
    return (
      <div
        className={`aspect-video bg-gray-900 flex items-center justify-center ${className}`}
      >
        <div className="text-red-500 text-center p-4">
          <p className="text-xl mb-2">⚠️</p>
          <p>{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className={`relative bg-black group ${className}`}
      onMouseEnter={() => setShowControls(true)}
      onMouseLeave={() => setShowControls(false)}
    >
      {/* Vidéo */}
      <video
        ref={videoRef}
        className="w-full h-full"
        poster={poster}
        onClick={togglePlay}
        playsInline
      />

      {/* Titre */}
      {title && (
        <div className="absolute top-0 left-0 right-0 bg-gradient-to-b from-black/75 to-transparent p-4 opacity-0 group-hover:opacity-100 transition-opacity">
          <h3 className="text-white font-semibold text-lg">{title}</h3>
        </div>
      )}

      {/* Contrôles */}
      <div
        className={`absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black to-transparent p-4 transition-opacity ${
          showControls ? "opacity-100" : "opacity-0"
        }`}
      >
        {/* Barre de progression */}
        <div className="mb-3">
          <div className="relative h-1 bg-gray-600 rounded-full cursor-pointer group/progress">
            {/* Buffered */}
            <div
              className="absolute h-full bg-gray-400 rounded-full"
              style={{ width: `${bufferedPercentage}%` }}
            />
            {/* Progress */}
            <div
              className="absolute h-full bg-red-600 rounded-full"
              style={{ width: `${progressPercentage}%` }}
            />
            {/* Input invisible pour le seek */}
            <input
              type="range"
              min="0"
              max={duration || 0}
              value={currentTime}
              onChange={handleSeek}
              className="absolute inset-0 w-full opacity-0 cursor-pointer"
            />
          </div>
        </div>

        <div className="flex items-center gap-3 text-white">
          {/* Play/Pause */}
          <button
            onClick={togglePlay}
            className="hover:text-red-500 transition-colors"
          >
            {isPlaying ? <FiPause size={24} /> : <FiPlay size={24} />}
          </button>

          {/* Volume */}
          <button
            onClick={toggleMute}
            className="hover:text-red-500 transition-colors"
          >
            {isMuted ? <FiVolumeX size={20} /> : <FiVolume2 size={20} />}
          </button>

          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={volume}
            onChange={handleVolumeChange}
            className="w-20 accent-red-600"
          />

          {/* Time */}
          <div className="text-sm">
            {formatTime(currentTime)} / {formatTime(duration)}
          </div>

          <div className="flex-1" />

          {/* Qualité */}
          {onQualityChange && availableQualities.length > 1 && (
            <div className="relative">
              <button
                onClick={() => setShowSettings(!showSettings)}
                className="hover:text-red-500 transition-colors"
              >
                <FiSettings size={20} />
              </button>
              {showSettings && (
                <div className="absolute bottom-full right-0 mb-2 bg-gray-800 rounded-lg p-2 min-w-[120px]">
                  <div className="text-sm font-semibold mb-2 px-2">Qualité</div>
                  {availableQualities.map((quality) => (
                    <button
                      key={quality}
                      onClick={() => {
                        onQualityChange(quality);
                        setShowSettings(false);
                      }}
                      className={`block w-full text-left px-2 py-1 rounded hover:bg-gray-700 text-sm ${
                        quality === currentQuality ? "text-red-500" : ""
                      }`}
                    >
                      {quality === "auto" ? "Auto" : quality}
                    </button>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* Fullscreen */}
          <button
            onClick={toggleFullscreen}
            className="hover:text-red-500 transition-colors"
          >
            <FiMaximize size={20} />
          </button>
        </div>
      </div>

      {/* Badge méthode (dev) */}
      {process.env.NODE_ENV === "development" && (
        <div className="absolute top-2 right-2 px-2 py-1 bg-black/75 text-white text-xs rounded">
          {method.toUpperCase()} | {currentQuality}
        </div>
      )}
    </div>
  );
}
